"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setVerbose = exports.lookupConfig = exports.defaultConfig = exports.computeIfAbsent = exports.clearCache = exports.addProvider = void 0;
const _11000_config_node_devtools_1 = require("./providers/11000-config-node-devtools");
const _10000_cli_1 = require("./providers/10000-cli");
const _9000_cli_application_json_1 = require("./providers/9000-cli-application-json");
const _8000_env_application_json_1 = require("./providers/8000-env-application-json");
const _7000_individual_env_vars_1 = require("./providers/7000-individual-env-vars");
const _6000_config_trees_1 = require("./providers/6000-config-trees");
const _5000_application_profile_config_1 = require("./providers/5000-application-profile-config");
const _4000_application_profile_1 = require("./providers/4000-application-profile");
const _3000_application_config_1 = require("./providers/3000-application-config");
const _2000_application_1 = require("./providers/2000-application");
const _1000_application_packaged_1 = require("./providers/1000-application-packaged");
const _0000_programmatic_1 = require("./providers/0000-programmatic");
const util_1 = require("./util");
Object.defineProperty(exports, "computeIfAbsent", { enumerable: true, get: function () { return util_1.computeIfAbsent; } });
Object.defineProperty(exports, "setVerbose", { enumerable: true, get: function () { return util_1.setVerbose; } });
class ConfigProviderHolder {
    constructor(provider) {
        this.provider = provider;
        this.priority = this.provider.priority;
        this.cache = new Map;
    }
}
class KeyProviderPair {
}
const configProviderHolders = [];
const commonCache = new Map();
const stack = [];
const regex = /\$\{[^\$]+?\}/;
/**
 * Register one or more configuration providers.
 *
 * @param providers: ConfigProvider[] - the providers
 */
function addProvider(...providers) {
    providers.forEach(provider => configProviderHolders.push(new ConfigProviderHolder(provider)));
    configProviderHolders.sort(_compareProviders);
}
exports.addProvider = addProvider;
/**
 * A utility function to flush all the caches. (This is a hammer and should not generally be used. It's mostly useful un testing new provider implementations.)
 */
function clearCache() {
    configProviderHolders.forEach(configProvider => configProvider.cache.clear());
    commonCache.clear();
}
exports.clearCache = clearCache;
/**
 * A utility function to set a default configuration value programmatically.
 *
 * @param key - the key under which to store the value
 * @param value - the configuration value to store
 */
function defaultConfig(key, value) {
    commonCache.set(key, value);
}
exports.defaultConfig = defaultConfig;
/**
 * This function attempts to find a value for the given key which is looked up from the set of registered providers. This function is the workhorse of this API and is the main entrypoint for developers.
 * @param key - the key to be looked up
 * @returns a value which can be a string, a string[] or undefined
 */
function lookupConfig(key) {
    let value;
    for (var holder of configProviderHolders) {
        const pair = { key, provider: holder.provider };
        if (stack.find(p => p.key === pair.key && p.provider === pair.provider)) {
            continue;
        }
        stack.push(pair);
        try {
            let valueFromCache = false;
            if (!holder.cache.has(key)) {
                value = holder.provider.get(key, holder.cache, commonCache);
                if (value) {
                    if (Array.isArray(value)) {
                        if (value.length > 0 && typeof value[0] === 'string') {
                            value = value;
                        }
                        else {
                            value = [];
                        }
                        value = value.map(v => _interpolatePlaceholders(v));
                    }
                    else if (typeof value !== 'string') {
                        value = JSON.stringify(value);
                        value = _interpolatePlaceholders(value);
                    }
                    else {
                        value = _interpolatePlaceholders(value);
                    }
                    holder.cache.set(key, value);
                }
                // map undefined value so we don't process it over and over again
                holder.cache.set(key, value);
            }
            else {
                value = holder.cache.get(key);
                valueFromCache = true;
            }
            if (value) {
                util_1.verbose && console.debug('[config-node]', `Provider [${holder.provider.key}] returned${valueFromCache ? ' (from cache)' : ''}: `, key, '=', value);
                return value;
            }
        }
        finally {
            stack.pop();
        }
    }
    util_1.verbose && console.debug('[config-node]', `No Providers returned a value for:`, key);
}
exports.lookupConfig = lookupConfig;
function _compareProviders(a, b) {
    if (a.priority < b.priority) {
        return 1;
    }
    if (a.priority > b.priority) {
        return -1;
    }
    return 0;
}
function _interpolatePlaceholders(v) {
    let match = regex.exec(v);
    while (match) {
        // verbose && console.debug('[config-node]', 'Interpolating:', v, 'matched:', match);
        const key = match[0].slice(2, -1);
        const lookedUpValue = lookupConfig(key);
        if (lookedUpValue) {
            v = v.replace(match[0], lookedUpValue);
            match = regex.exec(v);
        }
        else {
            match = undefined;
        }
    }
    return v;
}
addProvider(_11000_config_node_devtools_1.configNodeDevtools, _10000_cli_1.cli, _9000_cli_application_json_1.cliApplicationJson, _8000_env_application_json_1.envApplicationJson, _7000_individual_env_vars_1.individualEnvVars, _6000_config_trees_1.configTrees, _5000_application_profile_config_1.applicationProfileConfig, _4000_application_profile_1.applicationProfile, _3000_application_config_1.applicationConfig, _2000_application_1.application, _1000_application_packaged_1.applicationPackaged, _0000_programmatic_1.programmatic);
(0, util_1.setVerbose)(lookupConfig('config.node.config.verbose') === 'true');
//# sourceMappingURL=index.js.map