"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unquote = exports.verbose = exports.setVerbose = exports.readJSONFile = exports.protectedKeys = exports.getProjectRoot = exports.computeIfAbsent = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
let verbose = false;
exports.verbose = verbose;
const protectedKeys = [
    'config.node.config.trees',
    'config.node.profiles.active'
];
exports.protectedKeys = protectedKeys;
function findProjectRoot(currentPath = process.cwd()) {
    const hasPackageJson = fs_1.default.existsSync(path_1.default.join(currentPath, 'package.json'));
    if (hasPackageJson) {
        return currentPath;
    }
    if (currentPath === path_1.default.resolve('/')) {
        return null;
    }
    return findProjectRoot(path_1.default.dirname(currentPath));
}
/**
 * A utility function to get the root folder of the parent project, use this function to get the application.json file
 * when it's packaged in the client extension files.
 * */
function getProjectRoot() {
    const currentWorkingDirectory = process.cwd();
    const projectRoot = findProjectRoot(currentWorkingDirectory);
    return projectRoot;
}
exports.getProjectRoot = getProjectRoot;
/**
 * A utility function for providers that implements lazy computation of values when the cache does not contain the specified key.
 *
 * @param cache - the cache against which to lookup and store the value
 * @param key - the key to lookup and store the value under
 * @param fn - the function that will compute the value when no key is found in the cache
 * @returns the cached value (having been computed and added to the cache if absent when requested)
 */
function computeIfAbsent(cache, key, fn) {
    let value = cache.get(key);
    if (!value) {
        try {
            value = fn();
        }
        catch (e) {
            verbose && console.error('[config-node]', e);
        }
        if (value) {
            cache.set(key, value);
        }
    }
    return value;
}
exports.computeIfAbsent = computeIfAbsent;
function readJSONFile(path) {
    if (fs_1.default.existsSync(path)) {
        const contents = fs_1.default.readFileSync(path, 'utf8');
        try {
            return JSON.parse(contents);
        }
        catch (error) {
            console.error('[config-node]', 'contents', contents, error);
        }
    }
    return undefined;
}
exports.readJSONFile = readJSONFile;
/**
 * A utility function to enable verbose output from this library, convenient for debugging.
 *
 * @param b - verbose if true, false otherwise
 */
function setVerbose(b) {
    exports.verbose = verbose = b;
}
exports.setVerbose = setVerbose;
function unquote(it) {
    if (typeof it === "string") {
        if (it.startsWith('"') && it.endsWith('"')) {
            return it.slice(1, -1);
        }
        else if (it.startsWith('\'') && it.endsWith('\'')) {
            return it.slice(1, -1);
        }
        if (it.includes(',')) {
            return it.split(',');
        }
    }
    return it;
}
exports.unquote = unquote;
//# sourceMappingURL=index.js.map